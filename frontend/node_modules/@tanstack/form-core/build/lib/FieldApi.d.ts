import type { DeepKeys, DeepValue, Updater } from './utils';
import type { FormApi, ValidationError } from './FormApi';
import { Store } from '@tanstack/store';
export type ValidationCause = 'change' | 'blur' | 'submit';
type ValidateFn<TData, TFormData> = (value: TData, fieldApi: FieldApi<TData, TFormData>) => ValidationError;
type ValidateAsyncFn<TData, TFormData> = (value: TData, fieldApi: FieldApi<TData, TFormData>) => ValidationError | Promise<ValidationError>;
export interface FieldOptions<_TData, TFormData, 
/**
 * This allows us to restrict the name to only be a valid field name while
 * also assigning it to a generic
 */
TName = unknown extends TFormData ? string : DeepKeys<TFormData>, 
/**
 * If TData is unknown, we can use the TName generic to determine the type
 */
TData = unknown extends _TData ? DeepValue<TFormData, TName> : _TData> {
    name: TName;
    index?: TData extends any[] ? number : never;
    defaultValue?: TData;
    asyncDebounceMs?: number;
    asyncAlways?: boolean;
    onMount?: (formApi: FieldApi<TData, TFormData>) => void;
    onChange?: ValidateFn<TData, TFormData>;
    onChangeAsync?: ValidateAsyncFn<TData, TFormData>;
    onChangeAsyncDebounceMs?: number;
    onBlur?: ValidateFn<TData, TFormData>;
    onBlurAsync?: ValidateAsyncFn<TData, TFormData>;
    onBlurAsyncDebounceMs?: number;
    onSubmitAsync?: ValidateAsyncFn<TData, TFormData>;
    defaultMeta?: Partial<FieldMeta>;
}
export type FieldApiOptions<TData, TFormData> = FieldOptions<TData, TFormData> & {
    form: FormApi<TFormData>;
};
export type FieldMeta = {
    isTouched: boolean;
    touchedError?: ValidationError;
    error?: ValidationError;
    isValidating: boolean;
};
export type FieldState<TData> = {
    value: TData;
    meta: FieldMeta;
};
/**
 * TData may not be known at the time of FieldApi construction, so we need to
 * use a conditional type to determine if TData is known or not.
 *
 * If TData is not known, we use the TFormData type to determine the type of
 * the field value based on the field name.
 */
type GetTData<Name, TData, TFormData> = unknown extends TData ? DeepValue<TFormData, Name> : TData;
export declare class FieldApi<TData, TFormData> {
    #private;
    uid: number;
    form: FormApi<TFormData>;
    name: DeepKeys<TFormData>;
    /**
     * This is a hack that allows us to use `GetTData` without calling it everywhere
     *
     * Unfortunately this hack appears to be needed alongside the `TName` hack
     * further up in this file. This properly types all of the internal methods,
     * while the `TName` hack types the options properly
     */
    _tdata: GetTData<typeof this.name, TData, TFormData>;
    store: Store<FieldState<typeof this._tdata>>;
    state: FieldState<typeof this._tdata>;
    prevState: FieldState<typeof this._tdata>;
    options: FieldOptions<typeof this._tdata, TFormData>;
    constructor(opts: FieldApiOptions<TData, TFormData>);
    mount: () => () => void;
    update: (opts: FieldApiOptions<typeof this._tdata, TFormData>) => void;
    getValue: () => typeof this._tdata;
    setValue: (updater: Updater<typeof this._tdata>, options?: {
        touch?: boolean;
        notify?: boolean;
    }) => void;
    _getMeta: () => FieldMeta | undefined;
    getMeta: () => FieldMeta;
    setMeta: (updater: Updater<FieldMeta>) => void;
    getInfo: () => Record<DeepKeys<TFormData>, import("./FormApi").FieldInfo<TFormData>>[DeepKeys<TFormData>];
    pushValue: (value: typeof this._tdata extends any[] ? (typeof this._tdata)[number] : never) => void;
    insertValue: (index: number, value: typeof this._tdata extends any[] ? (typeof this._tdata)[number] : never) => void;
    removeValue: (index: number) => void;
    swapValues: (aIndex: number, bIndex: number) => void;
    getSubField: <TName extends DeepKeys<GetTData<DeepKeys<TFormData>, TData, TFormData>>>(name: TName) => FieldApi<DeepValue<GetTData<DeepKeys<TFormData>, TData, TFormData>, TName>, TFormData>;
    validateSync: (value: GetTData<DeepKeys<TFormData>, TData, TFormData> | undefined, cause: ValidationCause) => void;
    cancelValidateAsync: () => void;
    validateAsync: (value: GetTData<DeepKeys<TFormData>, TData, TFormData> | undefined, cause: ValidationCause) => Promise<ValidationError>;
    validate: (cause: ValidationCause, value?: typeof this._tdata) => ValidationError | Promise<ValidationError>;
    handleChange: (updater: Updater<typeof this._tdata>) => void;
    handleBlur: () => void;
}
export {};
//# sourceMappingURL=FieldApi.d.ts.map