{"version":3,"file":"utils.js","sources":["../../src/utils.ts"],"sourcesContent":["export type UpdaterFn<TInput, TOutput = TInput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput = TInput> =\n  | TOutput\n  | UpdaterFn<TInput, TOutput>\n\nexport function functionalUpdate<TInput, TOutput = TInput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as UpdaterFn<TInput, TOutput>)(input)\n    : updater\n}\n\n/**\n * Get a value from an object using a path, including dot notation.\n */\nexport function getBy(obj: any, path: any) {\n  const pathArray = makePathArray(path)\n  const pathObj = pathArray\n  return pathObj.reduce((current: any, pathPart: any) => {\n    if (typeof current !== 'undefined') {\n      return current[pathPart]\n    }\n    return undefined\n  }, obj)\n}\n\n/**\n * Set a value on an object using a path, including dot notation.\n */\nexport function setBy(obj: any, _path: any, updater: Updater<any>) {\n  const path = makePathArray(_path)\n\n  function doSet(parent?: any): any {\n    if (!path.length) {\n      return functionalUpdate(updater, parent)\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        return {\n          ...parent,\n          [key]: doSet(parent[key]),\n        }\n      }\n      return {\n        [key]: doSet(),\n      }\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        const prefix = parent.slice(0, key)\n        return [\n          ...(prefix.length ? prefix : new Array(key)),\n          doSet(parent[key]),\n          ...parent.slice(key + 1),\n        ]\n      }\n      return [...new Array(key), doSet()]\n    }\n\n    throw new Error('Uh oh!')\n  }\n\n  return doSet(obj)\n}\n\nconst reFindNumbers0 = /^(\\d*)$/gm\nconst reFindNumbers1 = /\\.(\\d*)\\./gm\nconst reFindNumbers2 = /^(\\d*)\\./gm\nconst reFindNumbers3 = /\\.(\\d*$)/gm\nconst reFindMultiplePeriods = /\\.{2,}/gm\n\nconst intPrefix = '__int__'\nconst intReplace = `${intPrefix}$1`\n\nfunction makePathArray(str: string) {\n  if (typeof str !== 'string') {\n    throw new Error('Path must be a string.')\n  }\n\n  return str\n    .replace('[', '.')\n    .replace(']', '')\n    .replace(reFindNumbers0, intReplace)\n    .replace(reFindNumbers1, `.${intReplace}.`)\n    .replace(reFindNumbers2, `${intReplace}.`)\n    .replace(reFindNumbers3, `.${intReplace}`)\n    .replace(reFindMultiplePeriods, '.')\n    .split('.')\n    .map((d) => {\n      if (d.indexOf(intPrefix) === 0) {\n        return parseInt(d.substring(intPrefix.length), 10)\n      }\n      return d\n    })\n}\n\nexport type RequiredByKey<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\n\ntype ComputeRange<\n  N extends number,\n  Result extends Array<unknown> = [],\n> = Result['length'] extends N\n  ? Result\n  : ComputeRange<N, [...Result, Result['length']]>\ntype Index40 = ComputeRange<40>[number]\n\n// Is this type a tuple?\ntype IsTuple<T> = T extends readonly any[] & { length: infer Length }\n  ? Length extends Index40\n    ? T\n    : never\n  : never\n\n// If this type is a tuple, what indices are allowed?\ntype AllowedIndexes<\n  Tuple extends ReadonlyArray<any>,\n  Keys extends number = never,\n> = Tuple extends readonly []\n  ? Keys\n  : Tuple extends readonly [infer _, ...infer Tail]\n  ? AllowedIndexes<Tail, Keys | Tail['length']>\n  : Keys\n\nexport type DeepKeys<T> = unknown extends T\n  ? keyof T\n  : object extends T\n  ? string\n  : T extends readonly any[] & IsTuple<T>\n  ? AllowedIndexes<T> | DeepKeysPrefix<T, AllowedIndexes<T>>\n  : T extends any[]\n  ? DeepKeys<T[number]>\n  : T extends Date\n  ? never\n  : T extends object\n  ? (keyof T & string) | DeepKeysPrefix<T, keyof T>\n  : never\n\ntype DeepKeysPrefix<T, TPrefix> = TPrefix extends keyof T & (number | string)\n  ? `${TPrefix}.${DeepKeys<T[TPrefix]> & string}`\n  : never\n\nexport type DeepValue<T, TProp> = T extends Record<string | number, any>\n  ? TProp extends `${infer TBranch}.${infer TDeepProp}`\n    ? DeepValue<T[TBranch], TDeepProp>\n    : T[TProp & string]\n  : never\n\ntype Narrowable = string | number | bigint | boolean\n\ntype NarrowRaw<A> =\n  | (A extends [] ? [] : never)\n  | (A extends Narrowable ? A : never)\n  | {\n      [K in keyof A]: A[K] extends Function ? A[K] : NarrowRaw<A[K]>\n    }\n\nexport type Narrow<A> = Try<A, [], NarrowRaw<A>>\n\ntype Try<A1, A2, Catch = never> = A1 extends A2 ? A1 : Catch\n\n// Hack to get TypeScript to show simplified types in error messages\nexport type Pretty<T> = { [K in keyof T]: T[K] } & {}\n"],"names":["functionalUpdate","updater","input","getBy","obj","path","pathArray","makePathArray","pathObj","reduce","current","pathPart","undefined","setBy","_path","doSet","parent","length","key","shift","Array","isArray","prefix","slice","Error","reFindNumbers0","reFindNumbers1","reFindNumbers2","reFindNumbers3","reFindMultiplePeriods","intPrefix","intReplace","str","replace","split","map","d","indexOf","parseInt","substring"],"mappings":"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"}