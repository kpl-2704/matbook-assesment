'use strict';

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.cjs');
var store = require('@tanstack/store');

let uid = 0;

/**
 * TData may not be known at the time of FieldApi construction, so we need to
 * use a conditional type to determine if TData is known or not.
 *
 * If TData is not known, we use the TFormData type to determine the type of
 * the field value based on the field name.
 */
var _leaseValidateAsync = /*#__PURE__*/new WeakMap();
class FieldApi {
  constructor(_opts) {
    var _this$_getMeta2;
    _rollupPluginBabelHelpers.defineProperty(this, "uid", void 0);
    _rollupPluginBabelHelpers.defineProperty(this, "form", void 0);
    _rollupPluginBabelHelpers.defineProperty(this, "name", void 0);
    /**
     * This is a hack that allows us to use `GetTData` without calling it everywhere
     *
     * Unfortunately this hack appears to be needed alongside the `TName` hack
     * further up in this file. This properly types all of the internal methods,
     * while the `TName` hack types the options properly
     */
    _rollupPluginBabelHelpers.defineProperty(this, "_tdata", void 0);
    _rollupPluginBabelHelpers.defineProperty(this, "store", void 0);
    _rollupPluginBabelHelpers.defineProperty(this, "state", void 0);
    _rollupPluginBabelHelpers.defineProperty(this, "prevState", void 0);
    _rollupPluginBabelHelpers.defineProperty(this, "options", {});
    _rollupPluginBabelHelpers.defineProperty(this, "mount", () => {
      var _this$options$onMount, _this$options;
      const info = this.getInfo();
      info.instances[this.uid] = this;
      const unsubscribe = this.form.store.subscribe(() => {
        this.store.batch(() => {
          const nextValue = this.getValue();
          const nextMeta = this.getMeta();
          if (nextValue !== this.state.value) {
            this.store.setState(prev => ({
              ...prev,
              value: nextValue
            }));
          }
          if (nextMeta !== this.state.meta) {
            this.store.setState(prev => ({
              ...prev,
              meta: nextMeta
            }));
          }
        });
      });
      this.update(this.options);
      (_this$options$onMount = (_this$options = this.options).onMount) == null ? void 0 : _this$options$onMount.call(_this$options, this);
      return () => {
        unsubscribe();
        delete info.instances[this.uid];
        if (!Object.keys(info.instances).length) {
          delete this.form.fieldInfo[this.name];
        }
      };
    });
    _rollupPluginBabelHelpers.defineProperty(this, "update", opts => {
      // Default Value
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (this.state.value === undefined) {
        var _opts$form$options$de;
        const formDefault = (_opts$form$options$de = opts.form.options.defaultValues) == null ? void 0 : _opts$form$options$de[opts.name];
        if (opts.defaultValue !== undefined) {
          this.setValue(opts.defaultValue);
        } else if (formDefault !== undefined) {
          this.setValue(formDefault);
        }
      }

      // Default Meta
      if (this._getMeta() === undefined) {
        this.setMeta(this.state.meta);
      }
      this.options = opts;
    });
    _rollupPluginBabelHelpers.defineProperty(this, "getValue", () => {
      return this.form.getFieldValue(this.name);
    });
    _rollupPluginBabelHelpers.defineProperty(this, "setValue", (updater, options) => {
      this.form.setFieldValue(this.name, updater, options);
      this.validate('change', this.state.value);
    });
    _rollupPluginBabelHelpers.defineProperty(this, "_getMeta", () => this.form.getFieldMeta(this.name));
    _rollupPluginBabelHelpers.defineProperty(this, "getMeta", () => {
      var _this$_getMeta;
      return (_this$_getMeta = this._getMeta()) != null ? _this$_getMeta : {
        isValidating: false,
        isTouched: false,
        ...this.options.defaultMeta
      };
    });
    _rollupPluginBabelHelpers.defineProperty(this, "setMeta", updater => this.form.setFieldMeta(this.name, updater));
    _rollupPluginBabelHelpers.defineProperty(this, "getInfo", () => this.form.getFieldInfo(this.name));
    _rollupPluginBabelHelpers.defineProperty(this, "pushValue", value => this.form.pushFieldValue(this.name, value));
    _rollupPluginBabelHelpers.defineProperty(this, "insertValue", (index, value) => this.form.insertFieldValue(this.name, index, value));
    _rollupPluginBabelHelpers.defineProperty(this, "removeValue", index => this.form.removeFieldValue(this.name, index));
    _rollupPluginBabelHelpers.defineProperty(this, "swapValues", (aIndex, bIndex) => this.form.swapFieldValues(this.name, aIndex, bIndex));
    _rollupPluginBabelHelpers.defineProperty(this, "getSubField", name => new FieldApi({
      name: this.name + "." + name,
      form: this.form
    }));
    _rollupPluginBabelHelpers.defineProperty(this, "validateSync", (value = this.state.value, cause) => {
      const {
        onChange,
        onBlur
      } = this.options;
      const validate = cause === 'submit' ? undefined : cause === 'change' ? onChange : onBlur;
      if (!validate) return;

      // Use the validationCount for all field instances to
      // track freshness of the validation
      const validationCount = (this.getInfo().validationCount || 0) + 1;
      this.getInfo().validationCount = validationCount;
      const error = normalizeError(validate(value, this));
      if (this.state.meta.error !== error) {
        this.setMeta(prev => ({
          ...prev,
          error
        }));
      }

      // If a sync error is encountered, cancel any async validation
      if (this.state.meta.error) {
        this.cancelValidateAsync();
      }
    });
    _rollupPluginBabelHelpers.classPrivateFieldInitSpec(this, _leaseValidateAsync, {
      writable: true,
      value: () => {
        const count = (this.getInfo().validationAsyncCount || 0) + 1;
        this.getInfo().validationAsyncCount = count;
        return count;
      }
    });
    _rollupPluginBabelHelpers.defineProperty(this, "cancelValidateAsync", () => {
      // Lease a new validation count to ignore any pending validations
      _rollupPluginBabelHelpers.classPrivateFieldGet(this, _leaseValidateAsync).call(this);
      // Cancel any pending validation state
      this.setMeta(prev => ({
        ...prev,
        isValidating: false
      }));
    });
    _rollupPluginBabelHelpers.defineProperty(this, "validateAsync", async (value = this.state.value, cause) => {
      var _ref, _ref2;
      const {
        onChangeAsync,
        onBlurAsync,
        onSubmitAsync,
        asyncDebounceMs,
        onBlurAsyncDebounceMs,
        onChangeAsyncDebounceMs
      } = this.options;
      const validate = cause === 'change' ? onChangeAsync : cause === 'submit' ? onSubmitAsync : onBlurAsync;
      if (!validate) return;
      const debounceMs = cause === 'submit' ? 0 : (_ref = (_ref2 = cause === 'change' ? onChangeAsyncDebounceMs : onBlurAsyncDebounceMs) != null ? _ref2 : asyncDebounceMs) != null ? _ref : 0;
      if (this.state.meta.isValidating !== true) this.setMeta(prev => ({
        ...prev,
        isValidating: true
      }));

      // Use the validationCount for all field instances to
      // track freshness of the validation
      const validationAsyncCount = _rollupPluginBabelHelpers.classPrivateFieldGet(this, _leaseValidateAsync).call(this);
      const checkLatest = () => validationAsyncCount === this.getInfo().validationAsyncCount;
      if (!this.getInfo().validationPromise) {
        this.getInfo().validationPromise = new Promise((resolve, reject) => {
          this.getInfo().validationResolve = resolve;
          this.getInfo().validationReject = reject;
        });
      }
      if (debounceMs > 0) {
        await new Promise(r => setTimeout(r, debounceMs));
      }

      // Only kick off validation if this validation is the latest attempt
      if (checkLatest()) {
        try {
          const rawError = await validate(value, this);
          if (checkLatest()) {
            var _this$getInfo$validat, _this$getInfo;
            const error = normalizeError(rawError);
            this.setMeta(prev => ({
              ...prev,
              isValidating: false,
              error
            }));
            (_this$getInfo$validat = (_this$getInfo = this.getInfo()).validationResolve) == null ? void 0 : _this$getInfo$validat.call(_this$getInfo, error);
          }
        } catch (error) {
          if (checkLatest()) {
            var _this$getInfo$validat2, _this$getInfo2;
            (_this$getInfo$validat2 = (_this$getInfo2 = this.getInfo()).validationReject) == null ? void 0 : _this$getInfo$validat2.call(_this$getInfo2, error);
            throw error;
          }
        } finally {
          if (checkLatest()) {
            this.setMeta(prev => ({
              ...prev,
              isValidating: false
            }));
            delete this.getInfo().validationPromise;
          }
        }
      }

      // Always return the latest validation promise to the caller
      return this.getInfo().validationPromise;
    });
    _rollupPluginBabelHelpers.defineProperty(this, "validate", (cause, value) => {
      // If the field is pristine and validatePristine is false, do not validate
      if (!this.state.meta.isTouched) return;

      // Attempt to sync validate first
      this.validateSync(value, cause);

      // If there is an error, return it, do not attempt async validation
      if (this.state.meta.error) {
        if (!this.options.asyncAlways) {
          return this.state.meta.error;
        }
      }

      // No error? Attempt async validation
      return this.validateAsync(value, cause);
    });
    _rollupPluginBabelHelpers.defineProperty(this, "handleChange", updater => {
      this.setValue(updater, {
        touch: true
      });
    });
    _rollupPluginBabelHelpers.defineProperty(this, "handleBlur", () => {
      const prevTouched = this.state.meta.isTouched;
      if (!prevTouched) {
        this.setMeta(prev => ({
          ...prev,
          isTouched: true
        }));
        this.validate('change');
      }
      this.validate('blur');
    });
    this.form = _opts.form;
    this.uid = uid++;
    // Support field prefixing from FieldScope
    // let fieldPrefix = ''
    // if (this.form.fieldName) {
    //   fieldPrefix = `${this.form.fieldName}.`
    // }

    this.name = _opts.name;
    this.store = new store.Store({
      value: this.getValue(),
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      meta: (_this$_getMeta2 = this._getMeta()) != null ? _this$_getMeta2 : {
        isValidating: false,
        isTouched: false,
        ..._opts.defaultMeta
      }
    }, {
      onUpdate: () => {
        const state = this.store.state;
        state.meta.touchedError = state.meta.isTouched ? state.meta.error : undefined;
        this.prevState = state;
        this.state = state;
      }
    });
    this.state = this.store.state;
    this.prevState = this.state;
    this.options = _opts;
  }
}
function normalizeError(rawError) {
  if (rawError) {
    if (typeof rawError !== 'string') {
      return 'Invalid Form Values';
    }
    return rawError;
  }
  return undefined;
}

exports.FieldApi = FieldApi;
//# sourceMappingURL=FieldApi.cjs.map
