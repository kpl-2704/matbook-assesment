import { defineProperty as _defineProperty } from './_virtual/_rollupPluginBabelHelpers.js';
import { Store } from '@tanstack/store';
import { getBy, functionalUpdate, setBy } from './utils.js';

function getDefaultFormState(defaultState) {
  var _defaultState$values, _defaultState$fieldMe, _defaultState$canSubm, _defaultState$isField, _defaultState$isField2, _defaultState$isFormV, _defaultState$isFormV2, _defaultState$isSubmi, _defaultState$isSubmi2, _defaultState$isTouch, _defaultState$isValid, _defaultState$isValid2, _defaultState$submiss, _defaultState$formVal;
  return {
    values: (_defaultState$values = defaultState.values) != null ? _defaultState$values : {},
    fieldMeta: (_defaultState$fieldMe = defaultState.fieldMeta) != null ? _defaultState$fieldMe : {},
    canSubmit: (_defaultState$canSubm = defaultState.canSubmit) != null ? _defaultState$canSubm : true,
    isFieldsValid: (_defaultState$isField = defaultState.isFieldsValid) != null ? _defaultState$isField : false,
    isFieldsValidating: (_defaultState$isField2 = defaultState.isFieldsValidating) != null ? _defaultState$isField2 : false,
    isFormValid: (_defaultState$isFormV = defaultState.isFormValid) != null ? _defaultState$isFormV : false,
    isFormValidating: (_defaultState$isFormV2 = defaultState.isFormValidating) != null ? _defaultState$isFormV2 : false,
    isSubmitted: (_defaultState$isSubmi = defaultState.isSubmitted) != null ? _defaultState$isSubmi : false,
    isSubmitting: (_defaultState$isSubmi2 = defaultState.isSubmitting) != null ? _defaultState$isSubmi2 : false,
    isTouched: (_defaultState$isTouch = defaultState.isTouched) != null ? _defaultState$isTouch : false,
    isValid: (_defaultState$isValid = defaultState.isValid) != null ? _defaultState$isValid : false,
    isValidating: (_defaultState$isValid2 = defaultState.isValidating) != null ? _defaultState$isValid2 : false,
    submissionAttempts: (_defaultState$submiss = defaultState.submissionAttempts) != null ? _defaultState$submiss : 0,
    formValidationCount: (_defaultState$formVal = defaultState.formValidationCount) != null ? _defaultState$formVal : 0
  };
}
class FormApi {
  constructor(_opts) {
    var _opts$defaultValues, _opts$defaultState;
    // // This carries the context for nested fields
    _defineProperty(this, "options", {});
    _defineProperty(this, "store", void 0);
    // Do not use __state directly, as it is not reactive.
    // Please use form.useStore() utility to subscribe to state
    _defineProperty(this, "state", void 0);
    _defineProperty(this, "fieldInfo", {});
    _defineProperty(this, "fieldName", void 0);
    _defineProperty(this, "validationMeta", {});
    _defineProperty(this, "update", options => {
      if (!options) return;
      this.store.batch(() => {
        const shouldUpdateValues = options.defaultValues && options.defaultValues !== this.options.defaultValues && !this.state.isTouched;
        const shouldUpdateState = options.defaultState !== this.options.defaultState && !this.state.isTouched;
        this.store.setState(() => getDefaultFormState(Object.assign({}, this.state,
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        shouldUpdateState ? options.defaultState : {},
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        shouldUpdateValues ? {
          values: options.defaultValues
        } : {})));
      });
      this.options = options;
    });
    _defineProperty(this, "reset", () => this.store.setState(() => {
      var _this$options$default, _this$options$default2;
      return getDefaultFormState({
        ...this.options.defaultState,
        values: (_this$options$default = this.options.defaultValues) != null ? _this$options$default : (_this$options$default2 = this.options.defaultState) == null ? void 0 : _this$options$default2.values
      });
    }));
    _defineProperty(this, "validateAllFields", async cause => {
      const fieldValidationPromises = [];
      this.store.batch(() => {
        void Object.values(this.fieldInfo).forEach(field => {
          Object.values(field.instances).forEach(instance => {
            // If any fields are not touched
            if (!instance.state.meta.isTouched) {
              // Mark them as touched
              instance.setMeta(prev => ({
                ...prev,
                isTouched: true
              }));
              // Validate the field
              fieldValidationPromises.push(Promise.resolve().then(() => instance.validate(cause)));
            }
          });
        });
      });
      return Promise.all(fieldValidationPromises);
    });
    _defineProperty(this, "handleSubmit", async () => {
      // Check to see that the form and all fields have been touched
      // If they have not, touch them all and run validation
      // Run form validation
      // Submit the form

      this.store.setState(old => ({
        ...old,
        // Submission attempts mark the form as not submitted
        isSubmitted: false,
        // Count submission attempts
        submissionAttempts: old.submissionAttempts + 1
      }));

      // Don't let invalid forms submit
      if (!this.state.canSubmit) return;
      this.store.setState(d => ({
        ...d,
        isSubmitting: true
      }));
      const done = () => {
        this.store.setState(prev => ({
          ...prev,
          isSubmitting: false
        }));
      };

      // Validate all fields
      await this.validateAllFields('submit');

      // Fields are invalid, do not submit
      if (!this.state.isFieldsValid) {
        var _this$options$onSubmi, _this$options;
        done();
        (_this$options$onSubmi = (_this$options = this.options).onSubmitInvalid) == null ? void 0 : _this$options$onSubmi.call(_this$options, this.state.values, this);
        return;
      }

      // Run validation for the form
      // await this.validateForm()

      if (!this.state.isValid) {
        var _this$options$onSubmi2, _this$options2;
        done();
        (_this$options$onSubmi2 = (_this$options2 = this.options).onSubmitInvalid) == null ? void 0 : _this$options$onSubmi2.call(_this$options2, this.state.values, this);
        return;
      }
      try {
        var _this$options$onSubmi3, _this$options3;
        // Run the submit code
        await ((_this$options$onSubmi3 = (_this$options3 = this.options).onSubmit) == null ? void 0 : _this$options$onSubmi3.call(_this$options3, this.state.values, this));
        this.store.batch(() => {
          this.store.setState(prev => ({
            ...prev,
            isSubmitted: true
          }));
          done();
        });
      } catch (err) {
        done();
        throw err;
      }
    });
    _defineProperty(this, "getFieldValue", field => getBy(this.state.values, field));
    _defineProperty(this, "getFieldMeta", field => {
      return this.state.fieldMeta[field];
    });
    _defineProperty(this, "getFieldInfo", field => {
      var _this$fieldInfo;
      // eslint-disable-next-line  @typescript-eslint/no-unnecessary-condition
      return (_this$fieldInfo = this.fieldInfo)[field] || (_this$fieldInfo[field] = {
        instances: {}
      });
    });
    _defineProperty(this, "setFieldMeta", (field, updater) => {
      this.store.setState(prev => {
        return {
          ...prev,
          fieldMeta: {
            ...prev.fieldMeta,
            [field]: functionalUpdate(updater, prev.fieldMeta[field])
          }
        };
      });
    });
    _defineProperty(this, "setFieldValue", (field, updater, opts) => {
      const touch = opts == null ? void 0 : opts.touch;
      this.store.batch(() => {
        if (touch) {
          this.setFieldMeta(field, prev => ({
            ...prev,
            isTouched: true
          }));
        }
        this.store.setState(prev => {
          return {
            ...prev,
            values: setBy(prev.values, field, updater)
          };
        });
      });
    });
    _defineProperty(this, "pushFieldValue", (field, value, opts) => {
      return this.setFieldValue(field, prev => [...(Array.isArray(prev) ? prev : []), value], opts);
    });
    _defineProperty(this, "insertFieldValue", (field, index, value, opts) => {
      this.setFieldValue(field, prev => {
        return prev.map((d, i) => i === index ? value : d);
      }, opts);
    });
    _defineProperty(this, "removeFieldValue", (field, index, opts) => {
      this.setFieldValue(field, prev => {
        return prev.filter((_d, i) => i !== index);
      }, opts);
    });
    _defineProperty(this, "swapFieldValues", (field, index1, index2) => {
      this.setFieldValue(field, prev => {
        const prev1 = prev[index1];
        const prev2 = prev[index2];
        return setBy(setBy(prev, "" + index1, prev2), "" + index2, prev1);
      });
    });
    this.store = new Store(getDefaultFormState({
      ...(_opts == null ? void 0 : _opts.defaultState),
      values: (_opts$defaultValues = _opts == null ? void 0 : _opts.defaultValues) != null ? _opts$defaultValues : _opts == null ? void 0 : (_opts$defaultState = _opts.defaultState) == null ? void 0 : _opts$defaultState.values,
      isFormValid: true
    }), {
      onUpdate: () => {
        let {
          state
        } = this.store;
        // Computed state
        const fieldMetaValues = Object.values(state.fieldMeta);
        const isFieldsValidating = fieldMetaValues.some(field => field == null ? void 0 : field.isValidating);
        const isFieldsValid = !fieldMetaValues.some(field => field == null ? void 0 : field.error);
        const isTouched = fieldMetaValues.some(field => field == null ? void 0 : field.isTouched);
        const isValidating = isFieldsValidating || state.isFormValidating;
        const isFormValid = !state.formError;
        const isValid = isFieldsValid && isFormValid;
        const canSubmit = state.submissionAttempts === 0 && !isTouched || !isValidating && !state.isSubmitting && isValid;
        state = {
          ...state,
          isFieldsValidating,
          isFieldsValid,
          isFormValid,
          isValid,
          canSubmit,
          isTouched
        };
        this.store.state = state;
        this.state = state;
      }
    });
    this.state = this.store.state;
    this.update(_opts || {});
  }
}

export { FormApi };
//# sourceMappingURL=FormApi.js.map
