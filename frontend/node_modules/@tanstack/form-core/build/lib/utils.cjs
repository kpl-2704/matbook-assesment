'use strict';

function functionalUpdate(updater, input) {
  return typeof updater === 'function' ? updater(input) : updater;
}

/**
 * Get a value from an object using a path, including dot notation.
 */
function getBy(obj, path) {
  const pathArray = makePathArray(path);
  const pathObj = pathArray;
  return pathObj.reduce((current, pathPart) => {
    if (typeof current !== 'undefined') {
      return current[pathPart];
    }
    return undefined;
  }, obj);
}

/**
 * Set a value on an object using a path, including dot notation.
 */
function setBy(obj, _path, updater) {
  const path = makePathArray(_path);
  function doSet(parent) {
    if (!path.length) {
      return functionalUpdate(updater, parent);
    }
    const key = path.shift();
    if (typeof key === 'string') {
      if (typeof parent === 'object') {
        return {
          ...parent,
          [key]: doSet(parent[key])
        };
      }
      return {
        [key]: doSet()
      };
    }
    if (typeof key === 'number') {
      if (Array.isArray(parent)) {
        const prefix = parent.slice(0, key);
        return [...(prefix.length ? prefix : new Array(key)), doSet(parent[key]), ...parent.slice(key + 1)];
      }
      return [...new Array(key), doSet()];
    }
    throw new Error('Uh oh!');
  }
  return doSet(obj);
}
const reFindNumbers0 = /^(\d*)$/gm;
const reFindNumbers1 = /\.(\d*)\./gm;
const reFindNumbers2 = /^(\d*)\./gm;
const reFindNumbers3 = /\.(\d*$)/gm;
const reFindMultiplePeriods = /\.{2,}/gm;
const intPrefix = '__int__';
const intReplace = intPrefix + "$1";
function makePathArray(str) {
  if (typeof str !== 'string') {
    throw new Error('Path must be a string.');
  }
  return str.replace('[', '.').replace(']', '').replace(reFindNumbers0, intReplace).replace(reFindNumbers1, "." + intReplace + ".").replace(reFindNumbers2, intReplace + ".").replace(reFindNumbers3, "." + intReplace).replace(reFindMultiplePeriods, '.').split('.').map(d => {
    if (d.indexOf(intPrefix) === 0) {
      return parseInt(d.substring(intPrefix.length), 10);
    }
    return d;
  });
}

// Is this type a tuple?

// If this type is a tuple, what indices are allowed?

// Hack to get TypeScript to show simplified types in error messages

exports.functionalUpdate = functionalUpdate;
exports.getBy = getBy;
exports.setBy = setBy;
//# sourceMappingURL=utils.cjs.map
