import { Store } from '@tanstack/store';
import type { DeepKeys, DeepValue, Updater } from './utils';
import type { FieldApi, FieldMeta, ValidationCause } from './FieldApi';
export type FormOptions<TData> = {
    defaultValues?: TData;
    defaultState?: Partial<FormState<TData>>;
    asyncDebounceMs?: number;
    onMount?: (values: TData, formApi: FormApi<TData>) => ValidationError;
    onMountAsync?: (values: TData, formApi: FormApi<TData>) => ValidationError | Promise<ValidationError>;
    onMountAsyncDebounceMs?: number;
    onChange?: (values: TData, formApi: FormApi<TData>) => ValidationError;
    onChangeAsync?: (values: TData, formApi: FormApi<TData>) => ValidationError | Promise<ValidationError>;
    onChangeAsyncDebounceMs?: number;
    onBlur?: (values: TData, formApi: FormApi<TData>) => ValidationError;
    onBlurAsync?: (values: TData, formApi: FormApi<TData>) => ValidationError | Promise<ValidationError>;
    onBlurAsyncDebounceMs?: number;
    onSubmit?: (values: TData, formApi: FormApi<TData>) => any | Promise<any>;
    onSubmitInvalid?: (values: TData, formApi: FormApi<TData>) => void;
};
export type FieldInfo<TFormData> = {
    instances: Record<string, FieldApi<any, TFormData>>;
} & ValidationMeta;
export type ValidationMeta = {
    validationCount?: number;
    validationAsyncCount?: number;
    validationPromise?: Promise<ValidationError>;
    validationResolve?: (error: ValidationError) => void;
    validationReject?: (error: unknown) => void;
};
export type ValidationError = undefined | false | null | string;
export type FormState<TData> = {
    values: TData;
    isFormValidating: boolean;
    formValidationCount: number;
    isFormValid: boolean;
    formError?: ValidationError;
    fieldMeta: Record<DeepKeys<TData>, FieldMeta>;
    isFieldsValidating: boolean;
    isFieldsValid: boolean;
    isSubmitting: boolean;
    isTouched: boolean;
    isSubmitted: boolean;
    isValidating: boolean;
    isValid: boolean;
    canSubmit: boolean;
    submissionAttempts: number;
};
export declare class FormApi<TFormData> {
    options: FormOptions<TFormData>;
    store: Store<FormState<TFormData>>;
    state: FormState<TFormData>;
    fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData>>;
    fieldName?: string;
    validationMeta: ValidationMeta;
    constructor(opts?: FormOptions<TFormData>);
    update: (options?: FormOptions<TFormData>) => void;
    reset: () => void;
    validateAllFields: (cause: ValidationCause) => Promise<ValidationError[]>;
    handleSubmit: () => Promise<void>;
    getFieldValue: <TField extends DeepKeys<TFormData>>(field: TField) => DeepValue<TFormData, TField>;
    getFieldMeta: <TField extends DeepKeys<TFormData>>(field: TField) => FieldMeta | undefined;
    getFieldInfo: <TField extends DeepKeys<TFormData>>(field: TField) => Record<DeepKeys<TFormData>, FieldInfo<TFormData>>[TField];
    setFieldMeta: <TField extends DeepKeys<TFormData>>(field: TField, updater: Updater<FieldMeta>) => void;
    setFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, updater: Updater<DeepValue<TFormData, TField>>, opts?: {
        touch?: boolean;
    }) => void;
    pushFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, value: DeepValue<TFormData, TField>[number], opts?: {
        touch?: boolean;
    }) => void;
    insertFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, index: number, value: DeepValue<TFormData, TField>[number], opts?: {
        touch?: boolean;
    }) => void;
    removeFieldValue: <TField extends DeepKeys<TFormData>>(field: TField, index: number, opts?: {
        touch?: boolean;
    }) => void;
    swapFieldValues: <TField extends DeepKeys<TFormData>>(field: TField, index1: number, index2: number) => void;
}
//# sourceMappingURL=FormApi.d.ts.map